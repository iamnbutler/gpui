{"v":1,"op":"create_stream","id":"mle5ybmq-d9bf","ts":"2026-02-08T19:56:05.090998Z","by":"@iamnbutler","branch":"main","d":{"description":"Add a web renderer backend to GPUI, enabling GPUI apps to target the browser","name":"web-renderer"}}
{"v":1,"op":"create","id":"mle5ygkj-l0w1","ts":"2026-02-08T19:56:11.491712Z","by":"@iamnbutler","branch":"main","d":{"description":"Understand how GPUI currently renders: the platform abstraction layer, how elements produce draw commands, the rendering pipeline from Render trait through layout to painting. Identify the key traits and types that a web backend would need to implement.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's current rendering architecture"}}
{"v":1,"op":"create","id":"mle5yipw-j8la","ts":"2026-02-08T19:56:14.276747Z","by":"@iamnbutler","branch":"main","d":{"description":"Map out the Platform trait and per-platform implementations (macOS, Linux, Windows). Understand what a new platform backend must implement: window management, input handling, text system, GPU/rendering surfaces. Determine the minimal surface area needed for a web target.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's platform abstraction layer"}}
{"v":1,"op":"create","id":"mle5yk97-7nuv","ts":"2026-02-08T19:56:16.267136Z","by":"@iamnbutler","branch":"main","d":{"description":"Research approaches for rendering a GPU-accelerated UI framework in the browser: WebGPU, WebGL, Canvas 2D, hybrid DOM approaches. Consider trade-offs around text rendering, accessibility, performance, and bundle size. Look at prior art (Makepad, Xilem, Iced web targets, wgpu in browser).","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Survey web rendering strategies"}}
{"v":1,"op":"create","id":"mle5ymgm-fs8q","ts":"2026-02-08T19:56:19.126012Z","by":"@iamnbutler","branch":"main","d":{"description":"Understand how GPUI handles text shaping, font loading, and glyph rendering. Determine how these would map to browser APIs (Canvas measureText, OffscreenCanvas, browser font loading, or compiled-in shaping via cosmic-text/rustybuzz in WASM).","priority":"p2","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's text system and web equivalents"}}
{"v":1,"op":"create","id":"mle5yo8v-vtt5","ts":"2026-02-08T19:56:21.439447Z","by":"@iamnbutler","branch":"main","d":{"description":"Understand how GPUI dispatches keyboard, mouse, and focus events from the platform layer. Map these to browser DOM events. Consider IME, clipboard, drag-and-drop, and other input modalities.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's input and event handling for web"}}
{"v":1,"op":"create","id":"mle5ypzj-95yf","ts":"2026-02-08T19:56:23.695409Z","by":"@iamnbutler","branch":"main","d":{"description":"Attempt to compile GPUI core to wasm32-unknown-unknown. Identify platform-specific dependencies that block compilation (system font libraries, GPU backends, OS APIs). Map out what needs to be stubbed or replaced for WASM.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Evaluate WASM compilation feasibility for GPUI"}}
{"v":1,"op":"create_stream","id":"mle6w6iy-rqf8","ts":"2026-02-08T20:22:24.778151Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace all platform-specific text systems (CoreText, DirectWrite, cosmic-text) with Parley + swash as a unified pure-Rust text pipeline. This is a prerequisite for the web renderer but also simplifies the native platforms.","name":"parley-text-system"}}
{"v":1,"op":"create_stream","id":"mle6w7yw-218p","ts":"2026-02-08T20:22:26.648959Z","by":"@iamnbutler","branch":"main","d":{"description":"Reorganize gpui from a single crate into a cargo workspace: gpui_core (shared), gpui_native (platform impls + native executor), gpui_web (web platform + wgpu renderer), gpui (facade). This is the structural prerequisite for web support.","name":"workspace-split"}}
{"v":1,"op":"create","id":"mle6wflk-zwqe","ts":"2026-02-08T20:22:36.536802Z","by":"@iamnbutler","branch":"main","d":{"description":"Create a detailed mapping of every method in PlatformTextSystem (add_fonts, all_font_names, font_id, font_metrics, typographic_bounds, advance, glyph_for_char, glyph_raster_bounds, rasterize_glyph, layout_line) to their Parley/skrifa/swash equivalents. Identify gaps. Parley covers font loading→shaping→layout. Skrifa covers font metrics, charmap, glyph bounds. Swash covers glyph rasterization (hinting, subpixel, color emoji). The rasterize_glyph and glyph_raster_bounds methods need swash.","priority":"p0","stream":"mle6w6iy-rqf8","tags":["research","text"],"title":"Map PlatformTextSystem trait to Parley/swash/skrifa APIs"}}
{"v":1,"op":"create","id":"mle6whzn-2cgn","ts":"2026-02-08T20:22:39.635800Z","by":"@iamnbutler","branch":"main","d":{"description":"Deep-read all three existing implementations to understand edge cases and behavior: (1) macOS CoreText impl in src/platform/mac/text_system.rs, (2) Windows DirectWrite impl in src/platform/windows/direct_write.rs, (3) Linux cosmic-text impl in src/platform/linux/text_system.rs. Document font fallback behavior, subpixel rendering differences, emoji handling, line layout output format. The new Parley impl must match the behavioral contract.","priority":"p0","stream":"mle6w6iy-rqf8","tags":["research","text"],"title":"Study existing PlatformTextSystem implementations"}}
{"v":1,"op":"create","id":"mle6wkxv-zlv1","ts":"2026-02-08T20:22:43.459567Z","by":"@iamnbutler","branch":"main","d":{"description":"Create a new PlatformTextSystem implementation backed by Parley (FontContext + LayoutContext), skrifa (font metrics/charmap), and swash (glyph rasterization). Key types: fontique::Collection for font management, parley::RangedBuilder for layout, swash::scale::ScaleContext for rasterization. Font registration via Collection::register_fonts(). On WASM, fontique has a dummy backend so fonts must be loaded as bytes.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Implement ParleyTextSystem struct"}}
{"v":1,"op":"create","id":"mle6wnqk-m6t2","ts":"2026-02-08T20:22:47.084195Z","by":"@iamnbutler","branch":"main","d":{"description":"Design how fonts are loaded on each platform with the unified Parley system. Native: fontique enumerates system fonts via CoreText/DirectWrite/fontconfig backends. Web (WASM): fontique dummy backend, fonts must be bundled as bytes and registered via register_fonts(). Decide on a default font bundle for web (e.g., Inter, a monospace font). Consider lazy font loading on web via fetch.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["design","text"],"title":"Handle font loading strategy per platform"}}
{"v":1,"op":"create","id":"mle6wq1j-dfce","ts":"2026-02-08T20:22:50.071936Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace the macOS CoreText text system with ParleyTextSystem as the first platform migration. Run existing tests and examples to validate rendering fidelity. Compare glyph positioning, font metrics, line layout output. This is the canary — if it works on macOS with visual parity, it'll work everywhere.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Wire ParleyTextSystem into GPUI and test on macOS"}}
{"v":1,"op":"create","id":"mle6wsvw-vim4","ts":"2026-02-08T20:22:53.756867Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace the cosmic-text + font-kit based text system on Linux with ParleyTextSystem. This should be straightforward since cosmic-text and Parley share HarfRust for shaping. Remove cosmic-text, font-kit, and pathfinder_geometry dependencies from Linux platform. Test on Linux.","priority":"p2","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Migrate Linux text system from cosmic-text to Parley"}}
{"v":1,"op":"create","id":"mle6wtm2-yvzx","ts":"2026-02-08T20:22:54.698226Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace DirectWrite-based text system on Windows with ParleyTextSystem. fontique has a Windows backend for system font enumeration. Test on Windows to verify rendering parity.","priority":"p2","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Migrate Windows text system from DirectWrite to Parley"}}
{"v":1,"op":"create","id":"mle6wve7-u1yo","ts":"2026-02-08T20:22:57.007177Z","by":"@iamnbutler","branch":"main","d":{"description":"After all platforms are on Parley, remove: cosmic-text, font-kit (custom Zed fork), core-text (macOS), DirectWrite text code, pathfinder_geometry. Clean up Cargo.toml. This significantly reduces the dependency tree and eliminates platform-specific text code.","priority":"p3","stream":"mle6w6iy-rqf8","tags":["cleanup","text"],"title":"Remove old text system dependencies"}}
{"v":1,"op":"create","id":"mle6x4kz-bsmn","ts":"2026-02-08T20:23:08.915170Z","by":"@iamnbutler","branch":"main","d":{"description":"Determine exactly what goes into gpui_core vs stays in platform crates. Based on research, gpui_core should contain: Element/Render/RenderOnce traits, Style/Styled, Geometry types, Scene primitives (7 types: Quad, Shadow, Path, Underline, MonochromeSprite, PolychromeSprite, PaintSurface), Taffy layout integration, App/Context<T>/Entity<T>/AsyncApp/AsyncWindowContext, Action system/key dispatch/keymap, Executor types (BackgroundExecutor/ForegroundExecutor/Task<T>) as wrappers around PlatformDispatcher, Platform traits (Platform, PlatformWindow, PlatformDisplay, PlatformDispatcher, PlatformTextSystem, PlatformAtlas), Input types/interactive elements, View/subscription/global, all built-in elements (div, img, text, list, svg, canvas...), Color/SharedString/prelude. Key question: where does the ParleyTextSystem live? If it's the unified impl for all platforms, it could go in gpui_core.","priority":"p0","stream":"mle6w7yw-218p","tags":["design","architecture"],"title":"Define the gpui_core boundary"}}
{"v":1,"op":"create","id":"mle6x8dl-v6a6","ts":"2026-02-08T20:23:13.833263Z","by":"@iamnbutler","branch":"main","d":{"description":"Many types in GPUI are pub(crate). When splitting into a workspace, these become cross-crate boundaries that need to be pub or pub in a shared crate. Audit all pub(crate) items to determine: which ones need to become pub (part of the platform trait contract), which can stay internal to gpui_core, which are only used within a single platform impl. Key areas: platform.rs traits are already pub(crate) and define the contract, arena/bounds_tree/queue are internal infra.","priority":"p1","stream":"mle6w7yw-218p","tags":["research","architecture"],"title":"Audit pub(crate) boundaries for the split"}}
{"v":1,"op":"create","id":"mle6xb30-vyps","ts":"2026-02-08T20:23:17.340984Z","by":"@iamnbutler","branch":"main","d":{"description":"Restructure from single crate to workspace. Root Cargo.toml becomes workspace definition. Create: crates/gpui_core/ (shared framework), crates/gpui_native/ (mac+windows+linux platform impls), crates/gpui_web/ (web platform impl), crates/gpui/ (facade that re-exports core + cfg-selects platform). Move files, update mod declarations, fix imports. The examples/ directory stays at root and depends on the gpui facade crate.","priority":"p1","stream":"mle6w7yw-218p","tags":["implementation","architecture"],"title":"Create cargo workspace structure"}}
{"v":1,"op":"create","id":"mle6xf4u-zlet","ts":"2026-02-08T20:23:22.590017Z","by":"@iamnbutler","branch":"main","d":{"description":"The executor is the trickiest part of the split. BackgroundExecutor/ForegroundExecutor/Task<T> are used pervasively through App/Context/AsyncApp. They wrap PlatformDispatcher. Plan: executor types + PlatformDispatcher trait live in gpui_core. Actual dispatcher impls (GCD, Linux thread pool, Windows ThreadPool, Web spawn_local) live in platform crates. Key concern: block() and block_with_timeout() in executor.rs use parking::Parker — these must be cfg-gated or redesigned for web. Scope::drop() calls block() — needs async alternative on web. await_on_background() is defined but never called (safe to cfg-gate). App quit() calls block_with_timeout() — needs web alternative.","priority":"p1","stream":"mle6w7yw-218p","tags":["design","architecture"],"title":"Handle the executor split"}}
{"v":1,"op":"create","id":"mle6xhzo-42aq","ts":"2026-02-08T20:23:26.292861Z","by":"@iamnbutler","branch":"main","d":{"description":"Current build.rs compiles Metal shaders (xcrun), HLSL shaders (fxc.exe), validates WGSL (naga), generates C headers (cbindgen), and generates GCD bindings (bindgen). This needs to split: gpui_native gets the shader compilation and FFI generation, gpui_web gets wgpu shader handling (WGSL validation or pre-compilation), gpui_core gets no build.rs or a minimal one.","priority":"p2","stream":"mle6w7yw-218p","tags":["implementation","architecture"],"title":"Handle build.rs split"}}
{"v":1,"op":"complete","id":"mle5ygkj-l0w1","ts":"2026-02-08T20:23:33.173016Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5yipw-j8la","ts":"2026-02-08T20:23:33.198669Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5yk97-7nuv","ts":"2026-02-08T20:23:33.223119Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5ymgm-fs8q","ts":"2026-02-08T20:23:33.248600Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5yo8v-vtt5","ts":"2026-02-08T20:23:33.274517Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5ypzj-95yf","ts":"2026-02-08T20:23:33.296759Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"create","id":"mle6xv52-jiu0","ts":"2026-02-08T20:23:43.334638Z","by":"@iamnbutler","branch":"main","d":{"description":"Create the web Platform implementation. Minimum viable methods: background_executor/foreground_executor (web dispatcher), text_system (ParleyTextSystem), open_window (create canvas element + wgpu surface), run (register requestAnimationFrame loop + DOM event listeners — browser owns the event loop, so run() sets up callbacks and returns or uses wasm_bindgen_futures::spawn_local), quit/activate (no-op or window.close), displays (single display from window.innerWidth/Height + devicePixelRatio), window_appearance (prefers-color-scheme media query). Many methods can return defaults or no-op: credentials, file dialogs, menus, URL schemes, dock menu.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement WebPlatform struct"}}
{"v":1,"op":"create","id":"mle6xxlf-ahac","ts":"2026-02-08T20:23:46.515321Z","by":"@iamnbutler","branch":"main","d":{"description":"Create PlatformWindow implementation backed by an HTML canvas element + wgpu surface. Key methods: bounds/content_size (canvas dimensions), scale_factor (devicePixelRatio), draw(&Scene) (submit to wgpu renderer), on_input (register DOM event listeners for keyboard/mouse/wheel → convert to PlatformInput), on_request_frame (requestAnimationFrame callback), sprite_atlas (wgpu-based atlas). Input conversion: DOM MouseEvent→MouseDownEvent/MouseUpEvent/MouseMoveEvent, DOM KeyboardEvent→KeyDownEvent/KeyUpEvent, DOM WheelEvent→ScrollWheelEvent. Handle resize via ResizeObserver on canvas.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement WebWindow struct"}}
{"v":1,"op":"create","id":"mle6y19i-gxyu","ts":"2026-02-08T20:23:51.270571Z","by":"@iamnbutler","branch":"main","d":{"description":"Create PlatformDispatcher for web. Design: is_main_thread() always true for the main JS thread. dispatch() and dispatch_on_main_thread() use wasm_bindgen_futures::spawn_local (all foreground, no true background threads). dispatch_after() uses setTimeout. spawn_realtime() degrades to spawn_local. For the MVP, background work runs on the main thread via microtask queue — Web Workers can be added later for actual parallelism. The key insight from Vello: don't try to match native threading, just make it work single-threaded first.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement WebDispatcher"}}
{"v":1,"op":"create","id":"mle6y5mf-1vso","ts":"2026-02-08T20:23:56.919992Z","by":"@iamnbutler","branch":"main","d":{"description":"Create a renderer that consumes Scene and draws via wgpu/WebGPU. The existing WGSL shaders (src/platform/blade/shaders.wgsl, 1299 lines) are a strong starting point — WebGPU speaks WGSL natively. The Blade renderer (blade_renderer.rs) shows the rendering pipeline: 8 passes for quads/shadows/paths/underlines/mono sprites/poly sprites/surfaces. Need to adapt from Blade's API to wgpu's API. Key types: wgpu::Device, wgpu::Queue, wgpu::RenderPipeline. Atlas implementation needs wgpu textures (similar to blade_atlas.rs but using wgpu). Device/surface creation is async in wgpu — use wasm_bindgen_futures for setup.","priority":"p0","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement wgpu-based renderer"}}
{"v":1,"op":"create","id":"mle6yafb-k7i6","ts":"2026-02-08T20:24:03.143335Z","by":"@iamnbutler","branch":"main","d":{"description":"Three blocking call sites need web alternatives: (1) Scope::drop() calls executor.block() — on web, either panic with a clear message, or restructure Scope to be async-droppable. Scope is used via scoped()/scoped_priority() which are already async, so the blocking drop is a safety net. (2) App::quit() calls block_with_timeout() for shutdown observers — on web, skip waiting or make it fire-and-forget. (3) await_on_background() is NEVER CALLED — safe to cfg(not(wasm32)) gate. For MVP: cfg-gate block() and block_with_timeout() to panic on wasm32 with clear messages. These paths are unlikely to trigger in example rendering.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Handle blocking patterns for web"}}
{"v":1,"op":"create","id":"mle6ydkw-eyw8","ts":"2026-02-08T20:24:07.232618Z","by":"@iamnbutler","branch":"main","d":{"description":"Map browser DOM events to GPUI's PlatformInput enum. Mappings: mousedown/mouseup→MouseDown/MouseUp (convert button, position, modifiers), mousemove→MouseMove, wheel→ScrollWheel (handle deltaMode for pixels vs lines), keydown/keyup→KeyDown/KeyUp (handle key/code, modifiers, IME composition), focus/blur→active_status_change, pointerenter/pointerleave→hover_status_change. Handle devicePixelRatio scaling on all coordinates. Prevent default browser behaviors where needed (context menu, scrolling, text selection). Consider touch events for mobile web.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"DOM event → PlatformInput conversion layer"}}
{"v":1,"op":"create","id":"mle6ygwc-lqam","ts":"2026-02-08T20:24:11.532847Z","by":"@iamnbutler","branch":"main","d":{"description":"Set up build tooling: wasm-pack or cargo build --target wasm32-unknown-unknown + wasm-bindgen. Create an HTML harness that loads the WASM module, creates a canvas, and initializes the GPUI app. MVP target examples (no OS deps): hello_world, styling, layout, text, interactive_elements, creating_components, custom_drawing, focus_visible, gradient, scrollable, tab_stop. Set up a simple dev server for testing.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Build and serve WASM examples"}}
{"v":1,"op":"create","id":"mle6yjku-f0mo","ts":"2026-02-08T20:24:15.006045Z","by":"@iamnbutler","branch":"main","d":{"description":"Web has no system font enumeration (fontique dummy backend on wasm32). Need to bundle fonts as bytes in the WASM binary or fetch them at startup. For examples: include a default sans-serif (e.g., Inter) and monospace font. Register via ParleyTextSystem::add_fonts(). Consider: embed in binary (simple, larger WASM) vs fetch at startup (smaller binary, async loading). Start with embedded for simplicity.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Bundle fonts for web examples"}}
{"v":1,"op":"complete","id":"mle6wflk-zwqe","ts":"2026-02-08T20:37:35.310718Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"update","id":"mle6whzn-2cgn","ts":"2026-02-08T20:37:41.183821Z","by":"@iamnbutler","branch":"main","d":{"description":"Deep-read all three existing implementations to understand edge cases and behavior: (1) macOS CoreText impl in src/platform/mac/text_system.rs, (2) Windows DirectWrite impl in src/platform/windows/direct_write.rs, (3) Linux cosmic-text impl in src/platform/linux/text_system.rs. Focus on: how FontId is allocated and stored internally, font fallback behavior, subpixel rendering differences (macOS does 4x4 subpixel grid, Linux/Windows do 1x), emoji detection and polychrome vs monochrome handling, layout_line output format (how FontRun[] maps to ShapedRun[]/ShapedGlyph[]), how add_fonts registers font bytes. The Parley impl must match the behavioral contract — not the implementation details."}}
{"v":1,"op":"update","id":"mle6wkxv-zlv1","ts":"2026-02-08T20:37:45.938537Z","by":"@iamnbutler","branch":"main","d":{"description":"Create ParleyTextSystem implementing PlatformTextSystem (Send + Sync). Internal state: fontique::Collection for font DB, parley::FontContext wrapping it, swash::scale::ScaleContext for rasterization, a Vec or HashMap mapping FontId(usize) → skrifa font handle. Method mapping (all confirmed clean): add_fonts→Collection::register_fonts, all_font_names→iterate Collection families, font_id→Collection::query by family/weight/style, font_metrics→skrifa metrics (ascent/descent/leading/cap_height/x_height/units_per_em/underline/bounding_box), typographic_bounds→skrifa glyph metrics, advance→skrifa glyph advance, glyph_for_char→skrifa charmap, glyph_raster_bounds→swash ScaleContext+Render, rasterize_glyph→swash ScaleContext+Render to bitmap returning (Size<DevicePixels>, Vec<u8>), layout_line→parley RangedBuilder→Layout→iterate runs/glyphs mapping Glyph{id,x,y,advance}→ShapedGlyph{id,position,index,is_emoji}. Dependencies: parley, skrifa, fontique, swash (for rasterization only)."}}
{"v":1,"op":"update","id":"mle6wnqk-m6t2","ts":"2026-02-08T20:37:54.770616Z","by":"@iamnbutler","branch":"main","d":{"description":"Design font loading per platform with the unified Parley system. Native: fontique enumerates system fonts via platform backends (CoreText on macOS, DirectWrite on Windows, fontconfig on Linux). These work out of the box with fontique — no custom code needed beyond creating Collection. Web (WASM): fontique has a dummy backend, fonts must be registered as bytes via register_fonts(). The embedded default font (Inter) handles this baseline case. Additional fonts can be fetched at startup. Key design decision: fontique handles font fallback natively per-platform, so the hardcoded fallback stack in TextSystem::new() (.ZedMono, .ZedSans, Helvetica, Segoe UI, etc.) can be simplified to just rely on fontique's fallback + the embedded default font as ultimate fallback."}}
{"v":1,"op":"update","id":"mle6wq1j-dfce","ts":"2026-02-08T20:38:00.589534Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace the macOS CoreText text system with ParleyTextSystem as the first platform migration. Steps: (1) Add parley, skrifa, fontique, swash dependencies to Cargo.toml, (2) Create src/text_system/parley_text_system.rs with the ParleyTextSystem struct, (3) Wire it in via current_platform() or TextSystem::new() on macOS, (4) Run existing tests, (5) Run text-heavy examples (text.rs, styling.rs) and compare rendering visually. This is the canary — macOS has the strictest text rendering (4x4 subpixel variants) and CoreText is the most mature impl. If Parley matches here, it'll work everywhere. Key risk: subpixel rendering fidelity — swash may produce slightly different results than CoreText. Accept minor differences if layout and metrics match."}}
{"v":1,"op":"update","id":"mle6wsvw-vim4","ts":"2026-02-08T20:38:04.399317Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace cosmic-text + font-kit on Linux with ParleyTextSystem. This should be the easiest migration since cosmic-text and Parley share HarfRust for shaping and both are pure-Rust. fontique replaces font-kit for font discovery (fontique uses fontconfig on Linux natively). Remove dependencies: cosmic-text, font-kit (Zed fork), pathfinder_geometry. Test on Linux with examples."}}
{"v":1,"op":"update","id":"mle6wtm2-yvzx","ts":"2026-02-08T20:38:05.728283Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace DirectWrite text system on Windows with ParleyTextSystem. fontique has a Windows backend using DirectWrite for font enumeration, so system font discovery still works. Remove DirectWrite text rendering code (direct_write.rs). Test on Windows with examples."}}
{"v":1,"op":"create","id":"mle7gl16-i2f4","ts":"2026-02-08T20:38:16.698268Z","by":"@iamnbutler","branch":"main","d":{"description":"Bundle Inter (variable weight, OFL licensed) as GPUI's default/fallback font. This ensures consistent cross-platform rendering when apps want it, and provides the baseline font on web where system fonts aren't enumerable. Approach: include Inter's variable .ttf as a static byte slice (include_bytes\\!), register it via add_fonts() during TextSystem initialization. Make it available as a well-known name (e.g., 'Inter' or '.GPUIDefault'). Apps can opt into it or ignore it and use system fonts. Consider also including a monospace default (e.g., JetBrains Mono, also OFL). Size concern: Inter variable is ~300KB, acceptable for a framework default. On web this goes into the WASM binary — fine for MVP, can be lazy-loaded later.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Embed Inter as default font"}}
{"v":1,"op":"create","id":"mle7goag-z6ir","ts":"2026-02-08T20:38:20.920841Z","by":"@iamnbutler","branch":"main","d":{"description":"TextSystem::new() has a hardcoded fallback stack: .ZedMono, .ZedSans, Helvetica, Segoe UI, Ubuntu, Adwaita Sans, Cantarell, Noto Sans, DejaVu Sans, Arial. This is Zed-specific. With Parley: (1) fontique handles platform-native fallback automatically, (2) Inter is the embedded default fallback. Simplify the stack to just the embedded default font(s). Remove .ZedMono/.ZedSans references. The TODO comment on line 74 ('Remove this when Linux have implemented setting fallbacks') is resolved by fontique.","priority":"p2","stream":"mle6w6iy-rqf8","tags":["cleanup","text"],"title":"Clean up hardcoded fallback font stack"}}
{"v":1,"op":"update","id":"mle6wve7-u1yo","ts":"2026-02-08T20:38:24.140544Z","by":"@iamnbutler","branch":"main","d":{"description":"After all platforms are on Parley and tests pass, remove: cosmic-text dep, font-kit (Zed fork) dep, core-text crate (macOS text), DirectWrite text rendering code (windows/direct_write.rs), pathfinder_geometry dep, the old platform-specific text_system.rs files in mac/linux/windows. Clean up Cargo.toml platform-specific text deps. This significantly reduces the dependency tree and eliminates ~3 separate text rendering implementations in favor of one."}}
{"v":1,"op":"create_stream","id":"mle7hyvx-oqvb","ts":"2026-02-08T20:39:21.309553Z","by":"@iamnbutler","branch":"main","d":{"description":"Evaluate and migrate GPUI's custom geometry types to use glam where appropriate, keeping GPUI's unit system and layout types","name":"glam-migration"}}
{"v":1,"op":"create_stream","id":"mle7hzjs-z42h","ts":"2026-02-08T20:39:22.168161Z","by":"@iamnbutler","branch":"main","d":{"description":"Evaluate and migrate GPUI's custom color types to use an idiomatic color crate like palette, accounting for GPU-first design constraints","name":"color-crate"}}
{"v":1,"op":"create_stream","id":"mle7i08q-6lkz","ts":"2026-02-08T20:39:23.066101Z","by":"@iamnbutler","branch":"main","d":{"description":"Remove Zed-specific code, references, and assumptions from GPUI to make it a proper general-purpose UI framework","name":"remove-zed-specific"}}
{"v":1,"op":"create","id":"mle7i5qf-366w","ts":"2026-02-08T20:39:30.183347Z","by":"@iamnbutler","branch":"main","d":{"description":"Map out the full type hierarchy in geometry.rs: Point<T>, Size<T>, Bounds<T>, Edges<T>, Corners<T>, plus unit types (Pixels, DevicePixels, ScaledPixels, Rems), layout types (Length, DefiniteLength, AbsoluteLength), and custom traits (Along, Half, Negate, IsZero). Document which are candidates for glam replacement vs which must stay.","priority":"p1","stream":"mle7hyvx-oqvb","title":"Audit geometry.rs and catalog all types, traits, and their usage patterns"}}
{"v":1,"op":"create","id":"mle7i8bh-cyec","ts":"2026-02-08T20:39:33.533525Z","by":"@iamnbutler","branch":"main","d":{"description":"Determine which GPUI geometry types could be backed by glam (Point/Vec2, basic transforms) vs which must remain custom (Edges, Corners, Length types, unit wrappers). Consider: glam doesn't support generic type params, has no unit distinction, is 3D-focused. Write up a concrete proposal for what changes vs what stays.","priority":"p1","stream":"mle7hyvx-oqvb","title":"Evaluate glam as a dependency for low-level math types"}}
{"v":1,"op":"create","id":"mle7iagw-a7w6","ts":"2026-02-08T20:39:36.320787Z","by":"@iamnbutler","branch":"main","d":{"description":"If glam is adopted for underlying math, design wrapper types that preserve GPUI's compile-time unit safety (Pixels vs DevicePixels vs ScaledPixels). The current generic Point<T>/Size<T> pattern allows clean unit tracking - need equivalent with glam backing.","priority":"p2","stream":"mle7hyvx-oqvb","title":"Design unit-safe wrappers around glam types"}}
{"v":1,"op":"create","id":"mle7ic5o-96vq","ts":"2026-02-08T20:39:38.508539Z","by":"@iamnbutler","branch":"main","d":{"description":"TransformationMatrix in scene.rs and Transformation in elements/svg.rs are the strongest candidates for glam replacement - they do standard 2D affine math without GPUI-specific unit semantics. Start migration here as a proof of concept.","priority":"p2","stream":"mle7hyvx-oqvb","title":"Migrate TransformationMatrix to glam"}}
{"v":1,"op":"create","id":"mle7ig7h-21lz","ts":"2026-02-08T20:39:43.757964Z","by":"@iamnbutler","branch":"main","d":{"description":"Map out Rgba, Hsla, Background, ColorSpace types in color.rs (934 lines). Document: repr(C) layout requirements for GPU buffers, Oklab conversions in WGSL shaders, hex parsing, serialization. Identify what's CPU-side vs GPU-side.","priority":"p1","stream":"mle7hzjs-z42h","title":"Audit color.rs and catalog types, conversions, and GPU integration"}}
{"v":1,"op":"create","id":"mle7ij4l-k4v5","ts":"2026-02-08T20:39:47.541026Z","by":"@iamnbutler","branch":"main","d":{"description":"Key concerns: palette types don't use repr(C) so can't be directly mapped to GPU buffers; Oklab math lives in WGSL shaders not Rust; GPUI treats Hsla as primary while palette centers on sRGB. Evaluate: could palette handle CPU-side color math while keeping custom repr(C) types for GPU? What color operations is GPUI currently missing that palette provides (WCAG contrast, color adjustments, broader color spaces)?","priority":"p1","stream":"mle7hzjs-z42h","title":"Evaluate palette crate vs keeping custom color types"}}
{"v":1,"op":"create","id":"mle7ikrg-ymoz","ts":"2026-02-08T20:39:49.660787Z","by":"@iamnbutler","branch":"main","d":{"description":"Regardless of crate choice, GPUI is missing: saturation/lightness adjustments, hue rotation, WCAG contrast ratio calculations, color distance metrics, color harmony generation. Determine which of these a general-purpose UI framework actually needs and add them.","priority":"p2","stream":"mle7hzjs-z42h","title":"Add missing color operations"}}
{"v":1,"op":"create","id":"mle7in1t-ir6s","ts":"2026-02-08T20:39:52.625904Z","by":"@iamnbutler","branch":"main","d":{"description":"GPUI color types use repr(C) for zero-copy GPU mapping. If adopting palette, we need a strategy: conversion layer at GPU boundary? Custom newtypes over palette types with repr(C)? Keep current types and use palette only for computation? This is the key architectural decision.","priority":"p1","stream":"mle7hzjs-z42h","title":"Resolve GPU buffer layout constraints for color types"}}
{"v":1,"op":"create","id":"mle7iqtk-a8e0","ts":"2026-02-08T20:39:57.512229Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace .ZedSans, .ZedMono, ZedPlex Sans, ZedPlex Mono references in text_system.rs (lines 73-86, 928-929) with generic fallback names or make the fallback font stack configurable by the framework consumer.","priority":"p1","stream":"mle7i08q-6lkz","title":"Remove Zed-branded font names from text_system.rs"}}
{"v":1,"op":"create","id":"mle7isez-7pm5","ts":"2026-02-08T20:39:59.579754Z","by":"@iamnbutler","branch":"main","d":{"description":"Rename ZED_PATH_SAMPLE_COUNT, ZED_FONTS_GAMMA, ZED_FONTS_GRAYSCALE_ENHANCED_CONTRAST in blade_renderer.rs (lines 995-1006) to use GPUI_ prefix. Check for any other ZED_ prefixed env vars across the codebase.","priority":"p1","stream":"mle7i08q-6lkz","title":"Replace ZED_ environment variables with GPUI_ prefix"}}
{"v":1,"op":"create","id":"mle7iubl-876i","ts":"2026-02-08T20:40:02.049675Z","by":"@iamnbutler","branch":"main","d":{"description":"Remove 'In Zed...' references from doc comments in action.rs (lines 22, 70, 74, 86-90, 190), test_context.rs (line 434), key_dispatch.rs (line 44). Replace with general GPUI examples.","priority":"p2","stream":"mle7i08q-6lkz","title":"Update documentation to remove Zed-specific references"}}
{"v":1,"op":"create","id":"mle7ivlt-g0q4","ts":"2026-02-08T20:40:03.713768Z","by":"@iamnbutler","branch":"main","d":{"description":"Tests in keymap.rs (lines 235-668) use hardcoded editor/workspace/pane context strings. Replace with generic examples like 'app', 'panel', 'view' that don't assume a text editor hierarchy.","priority":"p2","stream":"mle7i08q-6lkz","title":"Generalize keymap test context strings"}}
{"v":1,"op":"create","id":"mle7ix58-b6qi","ts":"2026-02-08T20:40:05.708392Z","by":"@iamnbutler","branch":"main","d":{"description":"GPUI depends on zed-font-kit, zed-scap, zed-xim, and a custom calloop fork from zed-industries GitHub. Evaluate: can we use upstream versions? What patches do the forks carry? Can patches be upstreamed?","priority":"p1","stream":"mle7i08q-6lkz","title":"Evaluate zed-industries dependency forks for upstream alternatives"}}
{"v":1,"op":"create","id":"mle7izgj-zisg","ts":"2026-02-08T20:40:08.707015Z","by":"@iamnbutler","branch":"main","d":{"description":"10+ references to github.com/zed-industries/zed/issues across the codebase (keymap.rs, blade_renderer.rs, mac/window.rs, metal_renderer.rs, platform.rs, div.rs). Replace with self-contained explanations of the workarounds or link to new issues in the gpui repo.","priority":"p3","stream":"mle7i08q-6lkz","title":"Remove Zed GitHub issue references from comments"}}
{"v":1,"op":"create","id":"mle7j0fd-vuar","ts":"2026-02-08T20:40:09.961992Z","by":"@iamnbutler","branch":"main","d":{"description":"Line wrapper in text_system/line_wrapper.rs (line 189) has special handling for ⋯ character noted as Zed-specific. Make this configurable or remove the special-casing.","priority":"p3","stream":"mle7i08q-6lkz","title":"Remove Zed-specific line wrapper ellipsis behavior"}}
{"v":1,"op":"create","id":"mle7lfdl-pd1z","ts":"2026-02-08T20:42:02.649043Z","by":"@iamnbutler","branch":"main","d":{"description":"Build an example (or bench) that exercises EVERY aspect of the text system to validate the Parley migration. Must cover: (1) Multiple font families (serif, sans, mono) at various sizes (8px to 72px), (2) All font weights (thin through black, 100-900), (3) Italic and oblique styles, (4) Font features (ligatures, tabular numbers, stylistic alternates), (5) Unicode: Latin, CJK, Arabic (RTL), Devanagari, emoji (color + monochrome), combining characters, ZWJ sequences, (6) Mixed-script runs (English+Chinese in same line, emoji mid-word), (7) Line layout accuracy: measure widths, verify glyph positions, check ascent/descent/leading, (8) Subpixel rendering at fractional positions, (9) Glyph rasterization: render glyphs at multiple sizes and scale factors (1x, 2x, 3x), verify bitmap output, (10) Font fallback: request a glyph not in the primary font, verify fallback resolves, (11) Edge cases: empty string, single character, very long lines, zero-width characters, (12) Performance: layout 10k lines, measure time. This example should be runnable as both a visual check and an automated regression test. Run it before and after the migration to compare output.","priority":"p0","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Create comprehensive text system test example"}}
{"v":1,"op":"assign","id":"mle6whzn-2cgn","ts":"2026-02-08T20:42:11.036283Z","by":"@iamnbutler","branch":"main","d":{"to":"@iamnbutler"}}
{"v":1,"op":"complete","id":"mle6whzn-2cgn","ts":"2026-02-08T20:42:46.796967Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle6wkxv-zlv1","ts":"2026-02-08T21:12:46.785065Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle7gl16-i2f4","ts":"2026-02-08T21:12:46.810251Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle6wnqk-m6t2","ts":"2026-02-08T21:12:46.834904Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle6wq1j-dfce","ts":"2026-02-08T21:12:46.859091Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle7lfdl-pd1z","ts":"2026-02-08T21:12:46.883489Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle6wsvw-vim4","ts":"2026-02-08T21:28:29.168349Z","by":"@iamnbutler","branch":"parley-text-system","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle6wtm2-yvzx","ts":"2026-02-08T21:28:29.194154Z","by":"@iamnbutler","branch":"parley-text-system","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle6wve7-u1yo","ts":"2026-02-08T21:33:41.153202Z","by":"@iamnbutler","branch":"parley-text-system","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle7goag-z6ir","ts":"2026-02-08T21:34:52.738388Z","by":"@iamnbutler","branch":"parley-text-system","d":{"resolution":"done"}}
