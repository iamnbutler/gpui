{"v":1,"op":"create_stream","id":"mle5ybmq-d9bf","ts":"2026-02-08T19:56:05.090998Z","by":"@iamnbutler","branch":"main","d":{"description":"Add a web renderer backend to GPUI, enabling GPUI apps to target the browser","name":"web-renderer"}}
{"v":1,"op":"create","id":"mle5ygkj-l0w1","ts":"2026-02-08T19:56:11.491712Z","by":"@iamnbutler","branch":"main","d":{"description":"Understand how GPUI currently renders: the platform abstraction layer, how elements produce draw commands, the rendering pipeline from Render trait through layout to painting. Identify the key traits and types that a web backend would need to implement.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's current rendering architecture"}}
{"v":1,"op":"create","id":"mle5yipw-j8la","ts":"2026-02-08T19:56:14.276747Z","by":"@iamnbutler","branch":"main","d":{"description":"Map out the Platform trait and per-platform implementations (macOS, Linux, Windows). Understand what a new platform backend must implement: window management, input handling, text system, GPU/rendering surfaces. Determine the minimal surface area needed for a web target.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's platform abstraction layer"}}
{"v":1,"op":"create","id":"mle5yk97-7nuv","ts":"2026-02-08T19:56:16.267136Z","by":"@iamnbutler","branch":"main","d":{"description":"Research approaches for rendering a GPU-accelerated UI framework in the browser: WebGPU, WebGL, Canvas 2D, hybrid DOM approaches. Consider trade-offs around text rendering, accessibility, performance, and bundle size. Look at prior art (Makepad, Xilem, Iced web targets, wgpu in browser).","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Survey web rendering strategies"}}
{"v":1,"op":"create","id":"mle5ymgm-fs8q","ts":"2026-02-08T19:56:19.126012Z","by":"@iamnbutler","branch":"main","d":{"description":"Understand how GPUI handles text shaping, font loading, and glyph rendering. Determine how these would map to browser APIs (Canvas measureText, OffscreenCanvas, browser font loading, or compiled-in shaping via cosmic-text/rustybuzz in WASM).","priority":"p2","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's text system and web equivalents"}}
{"v":1,"op":"create","id":"mle5yo8v-vtt5","ts":"2026-02-08T19:56:21.439447Z","by":"@iamnbutler","branch":"main","d":{"description":"Understand how GPUI dispatches keyboard, mouse, and focus events from the platform layer. Map these to browser DOM events. Consider IME, clipboard, drag-and-drop, and other input modalities.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Research GPUI's input and event handling for web"}}
{"v":1,"op":"create","id":"mle5ypzj-95yf","ts":"2026-02-08T19:56:23.695409Z","by":"@iamnbutler","branch":"main","d":{"description":"Attempt to compile GPUI core to wasm32-unknown-unknown. Identify platform-specific dependencies that block compilation (system font libraries, GPU backends, OS APIs). Map out what needs to be stubbed or replaced for WASM.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["research"],"title":"Evaluate WASM compilation feasibility for GPUI"}}
{"v":1,"op":"create_stream","id":"mle6w6iy-rqf8","ts":"2026-02-08T20:22:24.778151Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace all platform-specific text systems (CoreText, DirectWrite, cosmic-text) with Parley + swash as a unified pure-Rust text pipeline. This is a prerequisite for the web renderer but also simplifies the native platforms.","name":"parley-text-system"}}
{"v":1,"op":"create_stream","id":"mle6w7yw-218p","ts":"2026-02-08T20:22:26.648959Z","by":"@iamnbutler","branch":"main","d":{"description":"Reorganize gpui from a single crate into a cargo workspace: gpui_core (shared), gpui_native (platform impls + native executor), gpui_web (web platform + wgpu renderer), gpui (facade). This is the structural prerequisite for web support.","name":"workspace-split"}}
{"v":1,"op":"create","id":"mle6wflk-zwqe","ts":"2026-02-08T20:22:36.536802Z","by":"@iamnbutler","branch":"main","d":{"description":"Create a detailed mapping of every method in PlatformTextSystem (add_fonts, all_font_names, font_id, font_metrics, typographic_bounds, advance, glyph_for_char, glyph_raster_bounds, rasterize_glyph, layout_line) to their Parley/skrifa/swash equivalents. Identify gaps. Parley covers font loading→shaping→layout. Skrifa covers font metrics, charmap, glyph bounds. Swash covers glyph rasterization (hinting, subpixel, color emoji). The rasterize_glyph and glyph_raster_bounds methods need swash.","priority":"p0","stream":"mle6w6iy-rqf8","tags":["research","text"],"title":"Map PlatformTextSystem trait to Parley/swash/skrifa APIs"}}
{"v":1,"op":"create","id":"mle6whzn-2cgn","ts":"2026-02-08T20:22:39.635800Z","by":"@iamnbutler","branch":"main","d":{"description":"Deep-read all three existing implementations to understand edge cases and behavior: (1) macOS CoreText impl in src/platform/mac/text_system.rs, (2) Windows DirectWrite impl in src/platform/windows/direct_write.rs, (3) Linux cosmic-text impl in src/platform/linux/text_system.rs. Document font fallback behavior, subpixel rendering differences, emoji handling, line layout output format. The new Parley impl must match the behavioral contract.","priority":"p0","stream":"mle6w6iy-rqf8","tags":["research","text"],"title":"Study existing PlatformTextSystem implementations"}}
{"v":1,"op":"create","id":"mle6wkxv-zlv1","ts":"2026-02-08T20:22:43.459567Z","by":"@iamnbutler","branch":"main","d":{"description":"Create a new PlatformTextSystem implementation backed by Parley (FontContext + LayoutContext), skrifa (font metrics/charmap), and swash (glyph rasterization). Key types: fontique::Collection for font management, parley::RangedBuilder for layout, swash::scale::ScaleContext for rasterization. Font registration via Collection::register_fonts(). On WASM, fontique has a dummy backend so fonts must be loaded as bytes.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Implement ParleyTextSystem struct"}}
{"v":1,"op":"create","id":"mle6wnqk-m6t2","ts":"2026-02-08T20:22:47.084195Z","by":"@iamnbutler","branch":"main","d":{"description":"Design how fonts are loaded on each platform with the unified Parley system. Native: fontique enumerates system fonts via CoreText/DirectWrite/fontconfig backends. Web (WASM): fontique dummy backend, fonts must be bundled as bytes and registered via register_fonts(). Decide on a default font bundle for web (e.g., Inter, a monospace font). Consider lazy font loading on web via fetch.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["design","text"],"title":"Handle font loading strategy per platform"}}
{"v":1,"op":"create","id":"mle6wq1j-dfce","ts":"2026-02-08T20:22:50.071936Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace the macOS CoreText text system with ParleyTextSystem as the first platform migration. Run existing tests and examples to validate rendering fidelity. Compare glyph positioning, font metrics, line layout output. This is the canary — if it works on macOS with visual parity, it'll work everywhere.","priority":"p1","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Wire ParleyTextSystem into GPUI and test on macOS"}}
{"v":1,"op":"create","id":"mle6wsvw-vim4","ts":"2026-02-08T20:22:53.756867Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace the cosmic-text + font-kit based text system on Linux with ParleyTextSystem. This should be straightforward since cosmic-text and Parley share HarfRust for shaping. Remove cosmic-text, font-kit, and pathfinder_geometry dependencies from Linux platform. Test on Linux.","priority":"p2","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Migrate Linux text system from cosmic-text to Parley"}}
{"v":1,"op":"create","id":"mle6wtm2-yvzx","ts":"2026-02-08T20:22:54.698226Z","by":"@iamnbutler","branch":"main","d":{"description":"Replace DirectWrite-based text system on Windows with ParleyTextSystem. fontique has a Windows backend for system font enumeration. Test on Windows to verify rendering parity.","priority":"p2","stream":"mle6w6iy-rqf8","tags":["implementation","text"],"title":"Migrate Windows text system from DirectWrite to Parley"}}
{"v":1,"op":"create","id":"mle6wve7-u1yo","ts":"2026-02-08T20:22:57.007177Z","by":"@iamnbutler","branch":"main","d":{"description":"After all platforms are on Parley, remove: cosmic-text, font-kit (custom Zed fork), core-text (macOS), DirectWrite text code, pathfinder_geometry. Clean up Cargo.toml. This significantly reduces the dependency tree and eliminates platform-specific text code.","priority":"p3","stream":"mle6w6iy-rqf8","tags":["cleanup","text"],"title":"Remove old text system dependencies"}}
{"v":1,"op":"create","id":"mle6x4kz-bsmn","ts":"2026-02-08T20:23:08.915170Z","by":"@iamnbutler","branch":"main","d":{"description":"Determine exactly what goes into gpui_core vs stays in platform crates. Based on research, gpui_core should contain: Element/Render/RenderOnce traits, Style/Styled, Geometry types, Scene primitives (7 types: Quad, Shadow, Path, Underline, MonochromeSprite, PolychromeSprite, PaintSurface), Taffy layout integration, App/Context<T>/Entity<T>/AsyncApp/AsyncWindowContext, Action system/key dispatch/keymap, Executor types (BackgroundExecutor/ForegroundExecutor/Task<T>) as wrappers around PlatformDispatcher, Platform traits (Platform, PlatformWindow, PlatformDisplay, PlatformDispatcher, PlatformTextSystem, PlatformAtlas), Input types/interactive elements, View/subscription/global, all built-in elements (div, img, text, list, svg, canvas...), Color/SharedString/prelude. Key question: where does the ParleyTextSystem live? If it's the unified impl for all platforms, it could go in gpui_core.","priority":"p0","stream":"mle6w7yw-218p","tags":["design","architecture"],"title":"Define the gpui_core boundary"}}
{"v":1,"op":"create","id":"mle6x8dl-v6a6","ts":"2026-02-08T20:23:13.833263Z","by":"@iamnbutler","branch":"main","d":{"description":"Many types in GPUI are pub(crate). When splitting into a workspace, these become cross-crate boundaries that need to be pub or pub in a shared crate. Audit all pub(crate) items to determine: which ones need to become pub (part of the platform trait contract), which can stay internal to gpui_core, which are only used within a single platform impl. Key areas: platform.rs traits are already pub(crate) and define the contract, arena/bounds_tree/queue are internal infra.","priority":"p1","stream":"mle6w7yw-218p","tags":["research","architecture"],"title":"Audit pub(crate) boundaries for the split"}}
{"v":1,"op":"create","id":"mle6xb30-vyps","ts":"2026-02-08T20:23:17.340984Z","by":"@iamnbutler","branch":"main","d":{"description":"Restructure from single crate to workspace. Root Cargo.toml becomes workspace definition. Create: crates/gpui_core/ (shared framework), crates/gpui_native/ (mac+windows+linux platform impls), crates/gpui_web/ (web platform impl), crates/gpui/ (facade that re-exports core + cfg-selects platform). Move files, update mod declarations, fix imports. The examples/ directory stays at root and depends on the gpui facade crate.","priority":"p1","stream":"mle6w7yw-218p","tags":["implementation","architecture"],"title":"Create cargo workspace structure"}}
{"v":1,"op":"create","id":"mle6xf4u-zlet","ts":"2026-02-08T20:23:22.590017Z","by":"@iamnbutler","branch":"main","d":{"description":"The executor is the trickiest part of the split. BackgroundExecutor/ForegroundExecutor/Task<T> are used pervasively through App/Context/AsyncApp. They wrap PlatformDispatcher. Plan: executor types + PlatformDispatcher trait live in gpui_core. Actual dispatcher impls (GCD, Linux thread pool, Windows ThreadPool, Web spawn_local) live in platform crates. Key concern: block() and block_with_timeout() in executor.rs use parking::Parker — these must be cfg-gated or redesigned for web. Scope::drop() calls block() — needs async alternative on web. await_on_background() is defined but never called (safe to cfg-gate). App quit() calls block_with_timeout() — needs web alternative.","priority":"p1","stream":"mle6w7yw-218p","tags":["design","architecture"],"title":"Handle the executor split"}}
{"v":1,"op":"create","id":"mle6xhzo-42aq","ts":"2026-02-08T20:23:26.292861Z","by":"@iamnbutler","branch":"main","d":{"description":"Current build.rs compiles Metal shaders (xcrun), HLSL shaders (fxc.exe), validates WGSL (naga), generates C headers (cbindgen), and generates GCD bindings (bindgen). This needs to split: gpui_native gets the shader compilation and FFI generation, gpui_web gets wgpu shader handling (WGSL validation or pre-compilation), gpui_core gets no build.rs or a minimal one.","priority":"p2","stream":"mle6w7yw-218p","tags":["implementation","architecture"],"title":"Handle build.rs split"}}
{"v":1,"op":"complete","id":"mle5ygkj-l0w1","ts":"2026-02-08T20:23:33.173016Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5yipw-j8la","ts":"2026-02-08T20:23:33.198669Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5yk97-7nuv","ts":"2026-02-08T20:23:33.223119Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5ymgm-fs8q","ts":"2026-02-08T20:23:33.248600Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5yo8v-vtt5","ts":"2026-02-08T20:23:33.274517Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"complete","id":"mle5ypzj-95yf","ts":"2026-02-08T20:23:33.296759Z","by":"@iamnbutler","branch":"main","d":{"resolution":"done"}}
{"v":1,"op":"create","id":"mle6xv52-jiu0","ts":"2026-02-08T20:23:43.334638Z","by":"@iamnbutler","branch":"main","d":{"description":"Create the web Platform implementation. Minimum viable methods: background_executor/foreground_executor (web dispatcher), text_system (ParleyTextSystem), open_window (create canvas element + wgpu surface), run (register requestAnimationFrame loop + DOM event listeners — browser owns the event loop, so run() sets up callbacks and returns or uses wasm_bindgen_futures::spawn_local), quit/activate (no-op or window.close), displays (single display from window.innerWidth/Height + devicePixelRatio), window_appearance (prefers-color-scheme media query). Many methods can return defaults or no-op: credentials, file dialogs, menus, URL schemes, dock menu.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement WebPlatform struct"}}
{"v":1,"op":"create","id":"mle6xxlf-ahac","ts":"2026-02-08T20:23:46.515321Z","by":"@iamnbutler","branch":"main","d":{"description":"Create PlatformWindow implementation backed by an HTML canvas element + wgpu surface. Key methods: bounds/content_size (canvas dimensions), scale_factor (devicePixelRatio), draw(&Scene) (submit to wgpu renderer), on_input (register DOM event listeners for keyboard/mouse/wheel → convert to PlatformInput), on_request_frame (requestAnimationFrame callback), sprite_atlas (wgpu-based atlas). Input conversion: DOM MouseEvent→MouseDownEvent/MouseUpEvent/MouseMoveEvent, DOM KeyboardEvent→KeyDownEvent/KeyUpEvent, DOM WheelEvent→ScrollWheelEvent. Handle resize via ResizeObserver on canvas.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement WebWindow struct"}}
{"v":1,"op":"create","id":"mle6y19i-gxyu","ts":"2026-02-08T20:23:51.270571Z","by":"@iamnbutler","branch":"main","d":{"description":"Create PlatformDispatcher for web. Design: is_main_thread() always true for the main JS thread. dispatch() and dispatch_on_main_thread() use wasm_bindgen_futures::spawn_local (all foreground, no true background threads). dispatch_after() uses setTimeout. spawn_realtime() degrades to spawn_local. For the MVP, background work runs on the main thread via microtask queue — Web Workers can be added later for actual parallelism. The key insight from Vello: don't try to match native threading, just make it work single-threaded first.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement WebDispatcher"}}
{"v":1,"op":"create","id":"mle6y5mf-1vso","ts":"2026-02-08T20:23:56.919992Z","by":"@iamnbutler","branch":"main","d":{"description":"Create a renderer that consumes Scene and draws via wgpu/WebGPU. The existing WGSL shaders (src/platform/blade/shaders.wgsl, 1299 lines) are a strong starting point — WebGPU speaks WGSL natively. The Blade renderer (blade_renderer.rs) shows the rendering pipeline: 8 passes for quads/shadows/paths/underlines/mono sprites/poly sprites/surfaces. Need to adapt from Blade's API to wgpu's API. Key types: wgpu::Device, wgpu::Queue, wgpu::RenderPipeline. Atlas implementation needs wgpu textures (similar to blade_atlas.rs but using wgpu). Device/surface creation is async in wgpu — use wasm_bindgen_futures for setup.","priority":"p0","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Implement wgpu-based renderer"}}
{"v":1,"op":"create","id":"mle6yafb-k7i6","ts":"2026-02-08T20:24:03.143335Z","by":"@iamnbutler","branch":"main","d":{"description":"Three blocking call sites need web alternatives: (1) Scope::drop() calls executor.block() — on web, either panic with a clear message, or restructure Scope to be async-droppable. Scope is used via scoped()/scoped_priority() which are already async, so the blocking drop is a safety net. (2) App::quit() calls block_with_timeout() for shutdown observers — on web, skip waiting or make it fire-and-forget. (3) await_on_background() is NEVER CALLED — safe to cfg(not(wasm32)) gate. For MVP: cfg-gate block() and block_with_timeout() to panic on wasm32 with clear messages. These paths are unlikely to trigger in example rendering.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Handle blocking patterns for web"}}
{"v":1,"op":"create","id":"mle6ydkw-eyw8","ts":"2026-02-08T20:24:07.232618Z","by":"@iamnbutler","branch":"main","d":{"description":"Map browser DOM events to GPUI's PlatformInput enum. Mappings: mousedown/mouseup→MouseDown/MouseUp (convert button, position, modifiers), mousemove→MouseMove, wheel→ScrollWheel (handle deltaMode for pixels vs lines), keydown/keyup→KeyDown/KeyUp (handle key/code, modifiers, IME composition), focus/blur→active_status_change, pointerenter/pointerleave→hover_status_change. Handle devicePixelRatio scaling on all coordinates. Prevent default browser behaviors where needed (context menu, scrolling, text selection). Consider touch events for mobile web.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"DOM event → PlatformInput conversion layer"}}
{"v":1,"op":"create","id":"mle6ygwc-lqam","ts":"2026-02-08T20:24:11.532847Z","by":"@iamnbutler","branch":"main","d":{"description":"Set up build tooling: wasm-pack or cargo build --target wasm32-unknown-unknown + wasm-bindgen. Create an HTML harness that loads the WASM module, creates a canvas, and initializes the GPUI app. MVP target examples (no OS deps): hello_world, styling, layout, text, interactive_elements, creating_components, custom_drawing, focus_visible, gradient, scrollable, tab_stop. Set up a simple dev server for testing.","priority":"p1","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Build and serve WASM examples"}}
{"v":1,"op":"create","id":"mle6yjku-f0mo","ts":"2026-02-08T20:24:15.006045Z","by":"@iamnbutler","branch":"main","d":{"description":"Web has no system font enumeration (fontique dummy backend on wasm32). Need to bundle fonts as bytes in the WASM binary or fetch them at startup. For examples: include a default sans-serif (e.g., Inter) and monospace font. Register via ParleyTextSystem::add_fonts(). Consider: embed in binary (simple, larger WASM) vs fetch at startup (smaller binary, async loading). Start with embedded for simplicity.","priority":"p2","stream":"mle5ybmq-d9bf","tags":["implementation","web"],"title":"Bundle fonts for web examples"}}
